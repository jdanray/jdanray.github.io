<head>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<p>An independent set of a graph is a subset of the graph's vertices that are not adjacent to each other. A maximum independent set contains the largest possible number of such vertices.</p>

<p>In general, finding maximum independent sets is <a href="https://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard">NP-hard</a>. However, if the graph is a tree, then you can apply <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> to solve the problem in linear time.</p>

<p>There are a lot of ways that you can define what a tree is, and one way is to define it recursively. So, either a tree is empty or it's made up of a node and a list of subtrees. And the basic idea behind the algorithm here is to find the maximum independent set of the tree by finding the maximum independent sets of all the subtrees. Thus, you can find an optimal solution to the problem by finding optimal solutions to the problem's subproblems, which means that the problem has <a href="https://en.wikipedia.org/wiki/Optimal_substructure">optimal substructure</a>. Because the <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">subproblems also overlap</a>, the problem is a prime candidate for dynamic programming.</p>

<p>I put <a href="https://github.com/jdanray/blog-code/blob/master/dp/top_down_mis.py">my Python code</a> on <a href="https://github.com/jdanray/blog-code">my GitHub</a>. Although I prefer bottom-up dynamic programming in general, I took a top-down approach here, because I found it natural to recurse down the tree.</p>

<p>EDIT: I decided to design and implement <a href="https://github.com/jdanray/blog-code/blob/master/dp/bottom_up_mis.py">a bottom-up version of the algorithm</a>, too. In my implementation, a <a href="bfs.html">breadth-first traversal</a> of the tree orders the subproblems such that the tree's nodes are processed in ascending order, from the bottom level of the tree up to the root of the tree. With that ordering of the subproblems, any given subproblem's subsubproblems will already be solved, saved in the table, and ready for use.</p>

<p>Sources:</p>

<p>Dasgupta, S., C. H. Papadimitriou, and U. V. Vazirani. <i>Algorithms</i>. New York: McGraw-Hill Education, 2006.</p>
