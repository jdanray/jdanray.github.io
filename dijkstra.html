<head>
<title>Of Dijkstra and Priority Queues</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<p>Although I've implemented variants of <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a> in the past, I wanted to implement Dijkstra's algorithm with my own implementation of the <a href="http://pages.cs.wisc.edu/~vernon/cs367/notes/11.PRIORITY-Q.html">priority queue</a>. So, today I bring to you a reinvention of the wheel.</p>

<p>Especially when the project is small, I tend to develop software in Python and then translate the code into another language. Python is a clean, easy-to-use language that has a REPL. Consequently, it is quick and fun to develop in Python. Oftentimes there's a better tool for the job, but I like to use Python when I can. </p>

<p>In this case, I implemented Dijkstra's algorithm and the priority queue in Python and then translated the code into Java. So, I have:</p>

<p>
-<a href="https://github.com/jdanray/blog-code/blob/master/dijkstra/Heap.java">Java implementation of the priority queue</a><br />
-<a href="https://github.com/jdanray/blog-code/blob/master/dijkstra/Dijkstra.java">Java implementation of Dijkstra's algorithm</a><br />
-<a href="https://github.com/jdanray/blog-code/blob/master/dijkstra/heap.py">Python implementation of the priority queue</a><br />
-<a href="https://github.com/jdanray/blog-code/blob/master/dijkstra/dijkstra.py">Python implementation of Dijkstra's algorithm</a>
</p>

<p>One of the many interesting things that I learned from my artificial intelligence class is that the big difference between <a href="bfs.html">breadth-first search</a>, <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a>, and Dijkstra's algorithm is the data structure that stores vertices. </p>

<p>
In breadth-first search, the data structure is a <a href="queues.html">queue</a>. The first item that you put into it is the first item that you remove from it.<br />
In depth-first search, the data structure is a <a href="stacks.html">stack</a>. The last item that you put into it is the first item that you remove from it.<br />
In Dijkstra's algorithm, the data structure is a priority queue. The item that has the highest priority is the item that gets removed.
</p>

<p>You can actually think of stacks and queues as types of priority queues. A queue is a priority queue where elements have more precedence the earlier they enter the container. A stack is a priority queue where elements have more precedence the later they enter the container.</p>

<p>Priority queues are commonly implemented as <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html">binary heaps</a>, and that is how I implemented my priority queue. A binary heap is <a href="http://web.cecs.pdx.edu/~sheard/course/Cs163/Doc/FullvsComplete.html">a complete binary tree</a> that is ordered such that, for any given vertex, all of the vertex's children have lower priority than it.</p>

<p>Dijkstra's algorithm solves <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/singleSrcIntro.htm">the single-source shortest path problem</a>. In the single-source shortest path problem, you are given a graph and some distinguished vertex, and you want to find the shortest paths between the distinguished vertex and every other vertex in the graph. So, for example, let's say that you are in Atlanta, and you want to find the quickest routes to Dallas, Chicago, and New York. Represent the highway system as a graph, and then you can apply Dijkstra's algorithm to solve your problem.</p>

<p>At <a href="http://www2.lawrence.edu/fast/GREGGJ/CMSC150/101Graphs/Graphs.html">this page</a>, I found "a data file that represents a significant portion of the interstate highway system". So, I decided to actually <a href="https://github.com/jdanray/blog-code/blob/master/dijkstra/highways.py">compute the shortest paths from Atlanta to Dallas, Chicago, and New York</a>. In case you are dying to know, here are the results:</p>

<p>
The shortest distance between Atlanta and New York is 897 miles. The route is Atlanta -> Spartanburg -> Charlotte -> Greensboro -> Petersburg -> Richmond -> Washington -> Baltimore -> Philadelphia -> Newark -> New York.<br />
The shortest distance between Atlanta and Dallas is 791 miles. The route is Atlanta -> Birmingham -> Meridian -> Jackson -> Shreveport -> Dallas.<br />
The shortest distance between Atlanta and Chicago is 729 miles. The route is Atlanta -> Chattanooga -> Wildwood -> Nashville -> Louisville -> Indianapolis -> Gary -> Chicago.
</p>

<p>Of course, the quality of these results depends on the quality of the data and the quality of the program that operates on the data. However, these results are close to <a href="https://www.google.com/search?q=atlanta+to+new+york+miles">the results</a> <a href="https://www.google.com/search?q=atlanta+to+dallas+miles">that Google</a> <a href="https://www.google.com/search?q=atlanta+to+chicago+miles">turns up</a>. So, both the data and my implementation of Dijkstra's algorithm seem to be good.</p>

<p>For more of my programs, check out <a href="https://github.com/jdanray/blog-code/">my GitHub</a>.</p>
